<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playground X - Multi-Part Remedy Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <style>
        :root {
            --primary: #2563eb;
            --highlight: #fde047;
            --bg: #1e293b;
            --panel: #f8fafc;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Toolbar --- */
        .toolbar {
            background: white;
            padding: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 15px;
            align-items: center;
            z-index: 10;
        }

        .nav-controls { display: flex; gap: 10px; align-items: center; }
        
        .page-badge {
            background: #e2e8f0;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: bold;
            color: #334155;
            white-space: nowrap;
        }

        .search-wrapper {
            position: relative;
            flex-grow: 1;
            max-width: 600px;
        }

        #searchInput {
            width: 60%;
            padding: 12px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
            outline: none;
        }

        #searchInput:focus { border-color: var(--primary); }

        button {
            padding: 10px 20px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        button:disabled { opacity: 0.5; cursor: wait; }
        button:hover:not(:disabled) { opacity: 0.9; }

        .status-bar {
            background: #0f172a;
            color: #94a3b8;
            font-size: 0.8rem;
            padding: 5px 20px;
            text-align: right;
            border-top: 1px solid #334155;
        }

        /* --- Main Viewer --- */
        #viewerContainer {
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            justify-content: center;
            padding: 0rem;
            position: relative;
            background-color: #334155; /* Dark background for reading */
            margin-bottom: 0px
        }

        #pdfWrapper {
        
            position: relative;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
            margin-top:40px;
            margin-bottom: 600px;
            padding-bottom: 100px;
        }

        canvas { display: block; }

        #highlightLayer {
            position: absolute;
            top: 0; left: 0;
            pointer-events: none;
        }

        .highlight-box {
            position: absolute;
            background-color: var(--highlight);
            opacity: 0.4;
            border: 1px solid #eab308;
        }
    </style>
</head>
<body>

    <div class="toolbar">
        <div class="nav-controls">
            <button onclick="navigate(-1)">Previous</button>
            <span id="partInfo" class="page-badge">Loading...</span>
            <button onclick="navigate(1)">Next</button>
        </div>


        <div class="search-wrapper">
            <input type="text" id="searchInput" placeholder="Search (e.g. Headache)..." onkeydown="if(event.key === 'Enter') performGlobalSearch()">
            
            <span id="matchCounter" style="margin: 0 10px; font-size: 0.85rem; color: #334155; font-weight: bold;"></span>
            <button id="prevMatchBtn" onclick="navigateMatch(-1)" disabled style="padding: 5px 10px;">&uarr;</button>
            <button id="nextMatchBtn" onclick="navigateMatch(1)" disabled style="padding: 5px 10px;">&darr;</button>
            <button onclick="performGlobalSearch()">Search</button>
        </div>
        
        
    </div>

    <div id="viewerContainer">
        <div id="pdfWrapper">
            <canvas id="the-canvas"></canvas>
            <div id="highlightLayer"></div>
        </div>
    </div>

    <div class="status-bar" id="systemStatus">Initializing System...</div>

<script>
    // --- CONFIGURATION ---
    // Generates filenames: Part_1_Homeremedies.pdf ... Part_11_Homeremedies.pdf
    const totalParts = 11;
    const filePattern = (n) => `Part_${n}_Homeremedies.pdf`;

    // --- STATE ---
    let docs = []; // Array to hold the loaded PDF document objects
    let currentPartIndex = 0; // 0 to 10
    let currentPageIndex = 1; // 1-based page number
    let scale = .60;
    let isRendering = false;
    let pendingRender = null;
    // --- SEARCH STATE ---
    let searchResults = [];
    let currentMatchIndex = -1;
    
    // --- INITIALIZATION ---
    async function init() {
        const status = document.getElementById('systemStatus');
        const partInfo = document.getElementById('partInfo');
        
        status.innerText = `Loading ${totalParts} PDF parts into memory...`;
        
        try {
            // Load all documents sequentially to ensure order
            for (let i = 1; i <= totalParts; i++) {
                const filename = filePattern(i);
                try {
                    const doc = await pdfjsLib.getDocument(filename).promise;
                    docs.push({
                        id: i,
                        filename: filename,
                        pdf: doc,
                        totalPages: doc.numPages
                    });
                    partInfo.innerText = `Loaded Part ${i}/${totalParts}`;
                } catch (e) {
                    console.error(`Failed to load ${filename}`, e);
                    docs.push(null); // Placeholder for failed load
                }
            }

            status.innerText = "Ready. 11 Parts Loaded.";
            renderCurrentPage();

        } catch (error) {
            console.error(error);
            status.innerText = "Critical Error: Could not load PDFs.";
        }
    }

    // --- NAVIGATION LOGIC ---
    function navigate(offset) {
        if (isRendering) return;

        const currentDoc = docs[currentPartIndex];
        const newPage = currentPageIndex + offset;

        // 1. Simple page turn within current doc
        if (newPage >= 1 && newPage <= currentDoc.totalPages) {
            currentPageIndex = newPage;
            renderCurrentPage();
            return;
        }

        // 2. Jump to Previous Part (End)
        if (newPage < 1) {
            if (currentPartIndex > 0) {
                currentPartIndex--;
                // Go to the last page of the previous part
                currentPageIndex = docs[currentPartIndex].totalPages;
                renderCurrentPage();
            }
            return;
        }

        // 3. Jump to Next Part (Start)
        if (newPage > currentDoc.totalPages) {
            if (currentPartIndex < docs.length - 1) {
                currentPartIndex++;
                currentPageIndex = 1;
                renderCurrentPage();
            }
            return;
        }
    }

    // --- RENDERING LOGIC ---

    // --- HIGH-DEF RENDERING LOGIC ---
    function renderCurrentPage() {
        isRendering = true;
        const docObj = docs[currentPartIndex];
        
        document.getElementById('partInfo').innerText = `Part ${docObj.id} - Pg ${currentPageIndex}/${docObj.totalPages}`;
        
        docObj.pdf.getPage(currentPageIndex).then(page => {
            const canvas = document.getElementById('the-canvas');
            const ctx = canvas.getContext('2d');
            const wrapper = document.getElementById('pdfWrapper');
            const container = document.getElementById('viewerContainer');

            // 1. Get the device pixel ratio (1 for standard, 2 or 3 for Retina/4K)
            const dpr = window.devicePixelRatio || 1;

            // 2. Calculate available width 
            let availableWidth = container.clientWidth - 40; 
            if (availableWidth > 1000) availableWidth = 1000;

            // 3. Get unscaled viewport
            const unscaledViewport = page.getViewport({ scale: 1 });
            
            // 4. Calculate scale to fit width
            const scaleFactor = availableWidth / unscaledViewport.width;
            
            // 5. Create viewport for CSS dimensions (what you see)
            const viewport = page.getViewport({ scale: scaleFactor });

            // 6. Set Canvas dimensions:
            // CSS width/height = logical size (for layout)
            canvas.style.width = `${Math.floor(viewport.width)}px`;
            canvas.style.height = `${Math.floor(viewport.height)}px`;
            
            // Internal width/height = multiplied by DPR (for sharpness)
            canvas.width = Math.floor(viewport.width * dpr);
            canvas.height = Math.floor(viewport.height * dpr);

            // 7. Adjust highlights layer to match CSS size
            const highlightLayer = document.getElementById('highlightLayer');
            highlightLayer.style.width = `${Math.floor(viewport.width)}px`;
            highlightLayer.style.height = `${Math.floor(viewport.height)}px`;
            highlightLayer.innerHTML = '';

            // 8. Render with transform to account for high-DPI
            const renderContext = {
                canvasContext: ctx,
                viewport: viewport,
                transform: [dpr, 0, 0, dpr, 0, 0] // Magic sauce for sharpness
            };

            page.render(renderContext).promise.then(() => {
                isRendering = false;
                const query = document.getElementById('searchInput').value;
                if(query.length > 2) highlightTextOnPage(page, viewport, query);
            });
        });
    }





    

    // --- GLOBAL SEARCH LOGIC ---
    // --- IMPROVED SEARCH: FIND ALL ---
    async function performGlobalSearch() {
        const query = document.getElementById('searchInput').value.trim().toLowerCase();
        if (!query) return;

        const status = document.getElementById('systemStatus');
        const counter = document.getElementById('matchCounter');
        
        status.innerText = `Scanning all files...`;
        counter.innerText = "Scanning...";
        
        // 1. Reset results
        searchResults = [];
        currentMatchIndex = -1;
        document.getElementById('prevMatchBtn').disabled = true;
        document.getElementById('nextMatchBtn').disabled = true;

        // 2. Scan every page
        for (let pIdx = 0; pIdx < docs.length; pIdx++) {
            const docData = docs[pIdx];
            if (!docData) continue;

            for (let pg = 1; pg <= docData.totalPages; pg++) {
                // UI Breather (prevents freezing)
                if (pg % 20 === 0) await new Promise(r => setTimeout(r, 0));
                
                const page = await docData.pdf.getPage(pg);
                const textContent = await page.getTextContent();
                const textStr = textContent.items.map(s => s.str).join(' ').toLowerCase();

                if (textStr.includes(query)) {
                    // Store every match found
                    searchResults.push({ partIndex: pIdx, pageIndex: pg });
                }
            }
        }

        // 3. Handle Results
        if (searchResults.length > 0) {
            status.innerText = `Found ${searchResults.length} matches.`;
            document.getElementById('prevMatchBtn').disabled = false;
            document.getElementById('nextMatchBtn').disabled = false;
            // Jump to first match
            navigateMatch(1); 
        } else {
            status.innerText = "No matches found.";
            counter.innerText = "0 / 0";
        }
    }




    function navigateMatch(direction) {
        if (searchResults.length === 0) return;

        // Move index forward or backward
        // Note: The logic handles the initial state (-1) by starting at 0
        if (currentMatchIndex === -1 && direction === 1) {
            currentMatchIndex = 0;
        } else {
            currentMatchIndex += direction;
        }

        // Loop around if we hit the end
        if (currentMatchIndex >= searchResults.length) currentMatchIndex = 0;
        if (currentMatchIndex < 0) currentMatchIndex = searchResults.length - 1;

        // Update UI Counter
        document.getElementById('matchCounter').innerText = `${currentMatchIndex + 1} / ${searchResults.length}`;

        // Jump to the specific PDF Part and Page
        const match = searchResults[currentMatchIndex];
        currentPartIndex = match.partIndex;
        currentPageIndex = match.pageIndex;
        renderCurrentPage();
    }






    

    // --- HIGHLIGHTER ---
    async function highlightTextOnPage(page, viewport, query) {
        const textContent = await page.getTextContent();
        const textItems = textContent.items;
        const searchStr = query.toLowerCase();
        const highlightLayer = document.getElementById('highlightLayer');

        for (let i = 0; i < textItems.length; i++) {
            const item = textItems[i];
            if (item.str.toLowerCase().includes(searchStr)) {
                const tx = item.transform;
                // Approximate width/height if not provided by PDF
                const fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);
                const pdfRect = [
                    tx[4], tx[5], 
                    tx[4] + item.width, 
                    tx[5] + (item.height || fontHeight)
                ];
                
                const rect = viewport.convertToViewportRectangle(pdfRect);
                const div = document.createElement('div');
                div.className = 'highlight-box';
                
                // Normalization
                const x = Math.min(rect[0], rect[2]);
                const y = Math.min(rect[1], rect[3]);
                const w = Math.abs(rect[0] - rect[2]);
                const h = Math.abs(rect[1] - rect[3]);

                div.style.left = `${x}px`;
                div.style.top = `${y - h}px`; 
                div.style.width = `${w}px`;
                div.style.height = `${h}px`;

                highlightLayer.appendChild(div);
            }
        }
    }

    // Start the engine
    window.onload = init;

</script>

</body>
</html>

















