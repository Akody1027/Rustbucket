<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Playground X - Remedy Feed</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <style>
        :root {
            --primary: #2563eb;
            --highlight: #fde047;
            --bg: #1e293b;
            --glass: rgba(255, 255, 255, 0.95);
        }

        body {
            margin: 0; padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- TOP SEARCH (Fixed) --- */
        .top-bar {
            position: fixed;
            top: 0; left: 0; right: 0;
            background: var(--glass);
            backdrop-filter: blur(10px);
            padding: 10px 15px;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #searchInput {
            flex-grow: 1;
            padding: 10px 15px;
            border: 1px solid #cbd5e1;
            border-radius: 25px;
            font-size: 16px;
            outline: none;
            background: #f8fafc;
        }

        .btn-icon {
            background: #e2e8f0; border: none; border-radius: 50%;
            width: 36px; height: 36px; display: flex; align-items: center;
            justify-content: center; cursor: pointer; font-size: 18px; color: #334155;
        }
        .btn-icon:disabled { opacity: 0.3; }
        .btn-primary { background: var(--primary); color: white; }

        /* --- SCROLL CONTAINER --- */
        #scrollWindow {
            flex-grow: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding-top: 80px; /* Space for header */
            padding-bottom: 80px;
            background-color: #334155;
            position: relative;
        }

        /* The long strip that holds pages */
        #feedContainer {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        /* Individual Page Container (The Placeholder) */
        .page-container {
            width: 95%;
            background: white;
            min-height: 400px; /* Placeholder height before load */
            position: relative;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        canvas { display: block; width: 100%; height: auto; }

        /* Highlights */
        .highlight-layer {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
        }
        .highlight-box {
            position: absolute;
            background-color: var(--highlight);
            opacity: 0.4;
            border: 1px solid #eab308;
        }

        /* --- BOTTOM FLOATING INFO --- */
        .bottom-float {
            position: fixed;
            bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--glass);
            backdrop-filter: blur(10px);
            padding: 8px 20px;
            border-radius: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            font-weight: bold; color: #334155; font-size: 0.9rem;
            z-index: 100;
            pointer-events: none; /* Let clicks pass through */
        }

        /* Loading Bar */
        #loadingBar {
            position: fixed; top: 0; left: 0; height: 3px; background: #22c55e;
            width: 0%; transition: width 0.3s; z-index: 101;
        }
    </style>
</head>
<body>

    <div id="loadingBar"></div>

    <div class="top-bar">
        <input type="text" id="searchInput" placeholder="Search remedies..." onkeydown="if(event.key === 'Enter') performGlobalSearch()">
        <button class="btn-icon btn-primary" onclick="performGlobalSearch()">&#128269;</button> <span id="matchCounter" style="font-size: 0.8rem; font-weight: bold; white-space: nowrap;"></span>
        <button class="btn-icon" id="prevMatchBtn" onclick="navigateMatch(-1)" disabled>&uarr;</button>
        <button class="btn-icon" id="nextMatchBtn" onclick="navigateMatch(1)" disabled>&darr;</button>
    </div>

    <div id="scrollWindow">
        <div id="feedContainer">
            </div>
    </div>

    <div class="bottom-float" id="pageIndicator">Loading...</div>

<script>
    // --- CONFIGURATION ---
    const totalParts = 11;
    const filePattern = (n) => `Part_${n}_Homeremedies.pdf`;

    // --- STATE ---
    let docs = new Array(totalParts).fill(null); 
    let pageMap = []; // Maps Global Page # to { docIndex, pageIndex }
    let totalGlobalPages = 0;
    let observer; 
    
    // Search State
    let searchResults = [];
    let currentMatchIndex = -1;

    // --- INIT ---
    async function init() {
        const loadingBar = document.getElementById('loadingBar');
        loadingBar.style.width = "10%";
        
        // 1. Setup Intersection Observer (The "Buffer" Logic)
        // rootMargin: '2000px' means "Start loading images 2000px before they appear on screen"
        let options = {
            root: document.getElementById('scrollWindow'),
            rootMargin: '2000px 0px 2000px 0px', 
            threshold: 0.01
        };
        
        observer = new IntersectionObserver(handleIntersection, options);

        // 2. Load Docs Metadata (Progressive)
        await loadAllDocsMetadata();
        
        // 3. Build Skeleton UI
        buildSkeleton();
        
        loadingBar.style.width = "100%";
        setTimeout(() => loadingBar.style.width = "0%", 500);
        
        // 4. Update Page Indicator on Scroll
        document.getElementById('scrollWindow').addEventListener('scroll', updatePageIndicator);
    }

    async function loadAllDocsMetadata() {
        // We need to know how many pages are in each PDF to build the skeleton
        for (let i = 0; i < totalParts; i++) {
            const filename = filePattern(i + 1);
            try {
                const doc = await pdfjsLib.getDocument(filename).promise;
                docs[i] = doc;
                
                // Map every page of this doc to a global index
                for(let p=1; p<=doc.numPages; p++) {
                    pageMap.push({ docIndex: i, pageIndex: p, doc: doc });
                }
                totalGlobalPages += doc.numPages;
            } catch (e) {
                console.error(`Error loading ${filename}`, e);
            }
        }
    }

    function buildSkeleton() {
        const container = document.getElementById('feedContainer');
        container.innerHTML = '';

        // Create empty divs for every single page
        for (let i = 0; i < totalGlobalPages; i++) {
            const div = document.createElement('div');
            div.className = 'page-container';
            div.id = `page-${i}`;
            div.dataset.globalIndex = i;
            
            // Add canvas placeholder
            const canvas = document.createElement('canvas');
            div.appendChild(canvas);
            
            // Add Highlight Layer
            const hl = document.createElement('div');
            hl.className = 'highlight-layer';
            hl.id = `hl-${i}`;
            div.appendChild(hl);

            container.appendChild(div);
            
            // Tell observer to watch this div
            observer.observe(div);
        }
    }

    // --- THE BUFFER LOGIC ---
    function handleIntersection(entries, observer) {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                // Page is near viewport -> RENDER
                const div = entry.target;
                const index = parseInt(div.dataset.globalIndex);
                renderPage(index, div);
            } else {
                // Optional: Page is far away -> UNLOAD (to save memory)
                // For modern phones, 300 pages might hold in memory, but clearing canvas is safer
                // To keep it simple/smooth, we won't aggressively unload yet, 
                // but this is where you'd clear the canvas width/height to 0.
            }
        });
    }





    
    async function renderPage(globalIndex, containerDiv) {
        const canvas = containerDiv.querySelector('canvas');
        
        // If already rendered, skip
        if (canvas.getAttribute('data-rendered') === 'true') return;
        
        const map = pageMap[globalIndex];
        if (!map) return;

        try {
            const page = await map.doc.getPage(map.pageIndex);
            const ctx = canvas.getContext('2d');
            
            // --- FIX STARTS HERE ---
            const dpr = window.devicePixelRatio || 1;
            
            // 1. Get container width, but FORCE a minimum of 320px to prevent glitching
            const scrollWindow = document.getElementById('scrollWindow');
            const rawWidth = scrollWindow.clientWidth - 30; // margins
            const safeWidth = Math.max(rawWidth, 320); // Safety Net
            
            // 2. Cap max width at 1000px
            const finalW = Math.min(safeWidth, 1000);

            const unscaledViewport = page.getViewport({ scale: 1 });
            const scale = finalW / unscaledViewport.width;
            const viewport = page.getViewport({ scale: scale });
            // --- FIX ENDS HERE ---

            canvas.width = Math.floor(viewport.width * dpr);
            canvas.height = Math.floor(viewport.height * dpr);
            canvas.style.width = `${Math.floor(viewport.width)}px`;
            canvas.style.height = `${Math.floor(viewport.height)}px`;

            const renderContext = {
                canvasContext: ctx,
                viewport: viewport,
                transform: [dpr, 0, 0, dpr, 0, 0]
            };

            await page.render(renderContext).promise;
            canvas.setAttribute('data-rendered', 'true');
            
            // Re-apply highlights if search is active
            const query = document.getElementById('searchInput').value;
            if (query.length > 2) highlightOnPage(globalIndex, query);

        } catch (e) {
            console.error("Render error", e);
        }
    }






    
    // --- SCROLL SPY ---
    function updatePageIndicator() {
        // Find which page is currently centered
        const container = document.getElementById('feedContainer');
        const scrollPos = document.getElementById('scrollWindow').scrollTop + (window.innerHeight / 2);
        
        // Simple approximation or find element closest to scrollPos
        // We'll use the Intersection logic to update specific elements, 
        // but for the badge we can iterate children or just use a basic calculation.
        // For efficiency, let's just grab the center element using document.elementFromPoint
        
        const centerEl = document.elementFromPoint(window.innerWidth / 2, window.innerHeight / 2);
        const pageContainer = centerEl ? centerEl.closest('.page-container') : null;
        
        if (pageContainer) {
            const idx = parseInt(pageContainer.dataset.globalIndex);
            const map = pageMap[idx];
            document.getElementById('pageIndicator').innerText = `Part ${map.docIndex + 1} â€¢ Page ${map.pageIndex}`;
        }
    }

    // --- SEARCH ---
    async function performGlobalSearch() {
        const query = document.getElementById('searchInput').value.trim().toLowerCase();
        if (!query) return;

        const btn = document.querySelector('.btn-primary');
        const originalText = btn.innerText;
        btn.innerText = "...";
        
        searchResults = [];
        currentMatchIndex = -1;
        
        // Scan text content
        // Note: This can take time. We do it async.
        for (let i = 0; i < totalGlobalPages; i++) {
            if (i % 50 === 0) await new Promise(r => setTimeout(r, 0)); // UI Breath
            
            const map = pageMap[i];
            const page = await map.doc.getPage(map.pageIndex);
            const textContent = await page.getTextContent();
            const str = textContent.items.map(s => s.str).join(' ').toLowerCase();
            
            if (str.includes(query)) {
                searchResults.push(i);
                highlightOnPage(i, query); // Pre-highlight if rendered
            }
        }

        btn.innerText = originalText; // Reset button

        if (searchResults.length > 0) {
            document.getElementById('prevMatchBtn').disabled = false;
            document.getElementById('nextMatchBtn').disabled = false;
            navigateMatch(1);
        } else {
            alert("No matches found.");
            document.getElementById('matchCounter').innerText = "0/0";
        }
    }

    function navigateMatch(dir) {
        if (searchResults.length === 0) return;
        currentMatchIndex += dir;
        if (currentMatchIndex >= searchResults.length) currentMatchIndex = 0;
        if (currentMatchIndex < 0) currentMatchIndex = searchResults.length - 1;

        document.getElementById('matchCounter').innerText = `${currentMatchIndex + 1}/${searchResults.length}`;
        
        const globalIndex = searchResults[currentMatchIndex];
        const el = document.getElementById(`page-${globalIndex}`);
        
        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // Force render if not triggered yet
        renderPage(globalIndex, el);
        // Ensure highlight is drawn
        const query = document.getElementById('searchInput').value;
        highlightOnPage(globalIndex, query);
    }

    async function highlightOnPage(globalIndex, query) {
        const div = document.getElementById(`page-${globalIndex}`);
        const hlLayer = div.querySelector('.highlight-layer');
        hlLayer.innerHTML = '';
        
        const map = pageMap[globalIndex];
        const page = await map.doc.getPage(map.pageIndex);
        const textContent = await page.getTextContent();
        const str = query.toLowerCase();

        // Get viewport for math
        const canvas = div.querySelector('canvas');
        if (!canvas || !canvas.width) return; // Page not rendered yet
        
        // We need to reconstruct the viewport used for the canvas
        // This is tricky because we dynamically sized it.
        // Reverse engineer from CSS width
        const cssWidth = parseFloat(canvas.style.width);
        const unscaledViewport = page.getViewport({ scale: 1 });
        const scale = cssWidth / unscaledViewport.width;
        const viewport = page.getViewport({ scale: scale });

        textContent.items.forEach(item => {
            if (item.str.toLowerCase().includes(str)) {
                const tx = item.transform;
                const fontHeight = Math.sqrt(tx[2]*tx[2] + tx[3]*tx[3]);
                const pdfRect = [tx[4], tx[5], tx[4] + item.width, tx[5] + (item.height || fontHeight)];
                const rect = viewport.convertToViewportRectangle(pdfRect);
                
                const box = document.createElement('div');
                box.className = 'highlight-box';
                const x = Math.min(rect[0], rect[2]);
                const y = Math.min(rect[1], rect[3]);
                const w = Math.abs(rect[0] - rect[2]);
                const h = Math.abs(rect[1] - rect[3]);
                
                box.style.left = `${x}px`; box.style.top = `${y - h}px`;
                box.style.width = `${w}px`; box.style.height = `${h}px`;
                hlLayer.appendChild(box);
            }
        });
    }

    window.onload = init;
</script>

</body>
</html>

